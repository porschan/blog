---
title: Redis - 字符串（String）
date: 2020/3/12 23:48:21
---

字符串键是 Redis 最基本的键值对类型， 这种类型的键值对会在数据库里面把单独的一个键和单独的一个值关联起来， 被关联的键和值既可以是普通的文字数据， 也可以是图片、视频、音频、压缩文件等更为复杂的二进制数据。

Redis 为字符串键提供了一系列操作命令， 通过使用这些命令， 用户可以：
- 为字符串键设置值。
- 获取字符串键的值。
- 在获取旧值的同时为字符串键设置新值。
- 同时为多个字符串键设置值，或者同时获取多个字符串键的值。
- 取得字符串值的长度。
- 获取字符串值指定索引范围上的内容，或者对字符串值指定索引范围上的内容进行修改。
- 将一些内容追加到字符串值的末尾。
- 对字符串键储存的整数值或者浮点数值执行加法操作或减法操作。

# SET：为字符串键设置值

创建字符串键最常用的方法就是使用 SET 命令， 这个命令可以为一个字符串键设置相应的值。 在最基本的情况下， 用户只需要向 SET 命令提供一个键和一个值就可以了：

`SET key value`

跟之前提到过的一样， 这里的键和值既可以是文字也可以是二进制数据。

SET 命令在成功创建字符串键之后将返回 OK 作为结果。 比如说， 通过执行以下命令， 我们可以创建出一个字符串键， 它的键为 "number" ， 值为 "10086" ：

```
redis> SET number "10086"
OK
```

数据库键的存放方式
为了方便阅读， 本书总会将数据库中新出现的键放置到已有键的下方。 比如在上面展示的数据库图 2-3 里面， 我们就将新添加的 "number" 键和 "book" 键放置到了已有键的下方。

在实际中， Redis 数据库是以无序的方式存放数据库键的， 一个新加入的键可能会出现在数据库的任何位置上， 因此我们在使用 Redis 的过程中不应该对键在数据库中的摆放位置做任何假设， 以免造成错误。

改变覆盖规则

在默认情况下， 对一个已经设置了值的字符串键执行 SET 命令将导致键的旧值被新值覆盖。

举个例子， 如果我们连续执行以下两条 SET 命令， 那么第一条 SET 命令设置的值将被第二条 SET 命令设置的值所覆盖：

```
redis> SET song_title "Get Wild"
OK

redis> SET song_title "Running to Horizon"
OK
```

在第二条 SET 命令执行完毕之后， song_title 键的值将从原来的 "Get Wild" 变为 "Running to Horizon" 。

从 Redis 2.6.12 版本开始， 用户可以通过向 SET 命令提供可选的 NX 选项或者 XX 选项来指示 SET 命令是否要覆盖一个已经存在的值：

`SET key value [NX|XX]`

如果用户在执行 SET 命令时给定了 NX 选项， 那么 SET 命令只会在键没有值的情况下执行设置操作， 并返回 OK 表示设置成功； 如果键已经存在， 那么 SET 命令将放弃执行设置操作， 并返回空值 nil 表示设置失败。

以下代码展示了带有 NX 选项的 SET 命令的行为：

```
redis> SET password "123456" NX
OK    -- 对尚未有值的 password 键进行设置，成功

redis> SET password "999999" NX
(nil)    -- password 键已经有了值，设置失败
```

因为第二条 SET 命令没有改变 password 键的值， 所以 password 键的值仍然是刚开始时设置的 "123456" 。

另一方面， 如果用户在执行 SET 命令时给定了 XX 选项， 那么 SET 命令只会在键已经有值的情况下执行设置操作， 并返回 OK 表示设置成功； 如果给定的键并没有值， 那么 SET 命令将放弃执行设置操作， 并返回空值表示设置失败。

举个例子， 如果我们对一个没有值的键 mongodb-homepage 执行以下 SET 命令， 那么命令将因为 XX 选项的作用而放弃执行设置操作：

```
redis> SET mongodb-homepage "mongodb.com" XX
(nil)
```

相反地， 如果我们对一个已经有值的键执行带有 XX 选项的 SET 命令， 那么命令将使用新值去覆盖已有的旧值：

```
redis> SET mysql-homepage "mysql.org"
OK    -- 为键 mysql-homepage 设置一个值

redis> SET mysql-homepage "mysql.com" XX
OK    -- 对键的值进行更新
```

在第二条 SET 命令执行之后， mysql-homepage 键的值将从原来的 "mysql.org" 更新为 "mysql.com" 。

# GET：获取字符串键的值

用户可以通过使用 GET 命令， 从数据库里面获取指定字符串键的值：

`GET key`

GET 命令接受一个字符串键作为参数， 然后返回与该键相关联的值。

比如对于图 2-4 所示的数据库来说， 我们可以通过执行以下 GET 命令来取得各个字符串键相关联的值：

```
redis> GET message
"hello world"

redis> GET number
"10086"

redis> GET homepage
"redis.io"
```

另一方面， 如果用户给定的字符串键在数据库中并没有与之相关联的值， 那么 GET 命令将返回一个空值：

```
redis> GET date
(nil)
```

上面这个 GET 命令的执行结果表示数据库中并不存在 date 键， 它也没有与之相关联的值。

因为 Redis 的数据库要求所有键必须拥有与之相关联的值， 所以如果一个键有值， 那么我们就说这个键存在于数据库； 相反地， 如果一个键没有值， 那么我们就说这个键不存在于数据库。 比如对于上面展示的几个键来说， date 键就不存在于数据库， 而 message 键、 number 键和 homepage 键则存在于数据库。

# GETSET：获取旧值并设置新值

GETSET 命令就像 GET 命令和 SET 命令的组合版本， 它首先获取字符串键目前已有的值， 接着为键设置新值， 最后把之前获取到的旧值返回给用户：

`GETSET key new_value`

以下代码展示了如何使用 GETSET 命令去获取 number 键的旧值并为它设置新值：

```
redis> GET number    -- number 键现在的值为 "10086"
"10086"

redis> GETSET number "12345"
"10086"    -- 返回旧值

redis> GET number    -- number 键的值已被更新为 "12345"
"12345"
```

另一方面， 如果被设置的键并不存在于数据库， 那么 GETSET 命令将返回空值作为键的旧值：

```
redis> GET counter
(nil)    -- 键不存在

redis> GETSET counter 50
(nil)    -- 返回空值作为旧值

redis> GET counter
"50"
```

# 示例：缓存

对数据进行缓存是 Redis 最常见的用法之一： 因为 Redis 把数据储存在内存而不是硬盘上面， 并且访问内存数据的速度比访问硬盘数据的速度要快得多， 所以用户可以通过把需要快速访问的数据储存在 Redis 里面来提升应用程序访问这些数据时的速度。

代码清单 2-1 展示了一个使用 Redis 实现的缓存程序代码， 这个程序使用 SET 命令来将需要被缓存的数据储存到指定的字符串键里面， 并使用 GET 命令来从指定的字符串键里面获取被缓存的数据。

```python
class Cache:

    def __init__(self, client):
        self.client = client

    def set(self, key, value):
        """
        把需要被缓存的数据储存到键 key 里面，
        如果键 key 已经有值，那么使用新值去覆盖旧值。
        """
        self.client.set(key, value)

    def get(self, key):
        """
        获取储存在键 key 里面的缓存数据，
        如果数据不存在，那么返回 None 。
        """
        return self.client.get(key)

    def update(self, key, new_value):
        """
        对键 key 储存的缓存数据进行更新，
        并返回键 key 在被更新之前储存的缓存数据。
        如果键 key 之前并没有储存数据，
        那么返回 None 。
        """
        return self.client.getset(key, new_value)
```

除了用于设置缓存的 set() 方法以及用于获取缓存的 get() 方法之外， 缓存程序还提供了由 GETSET 命令实现的 update() 方法： 这个方法可以让用户在对缓存进行设置的同时， 获得之前被缓存的旧值。 用户可以根据自己的需要决定是使用 set() 方法还是 update() 方法对缓存进行设置。

以下代码展示了怎样使用这个程序来缓存一个 HTML 页面， 并在有需要时获取它：

```python
>>> from redis import Redis
>>> from cache import Cache
>>> client = Redis(decode_responses=True)  # 使用文本编码方式打开客户端
>>> cache = Cache(client)
>>> cache.set("greeting-page", "<html><p>hello world</p></html>")
>>> cache.get("greeting-page")
'<html><p>hello world</p></html>'
>>> cache.update("greeting-page", "<html><p>good morning</p></html>")
'<html><p>hello world</p></html>'
>>> cache.get("greeting-page")
'<html><p>good morning</p></html>'
```

因为 Redis 的字符串键不仅可以储存文本数据， 还可以储存二进制数据， 所以这个缓存程序不仅可以用来缓存网页等文本数据， 还可以用来缓存图片和视频等二进制数据。 比如说， 如果你正在运营一个图片网站， 那么你同样可以使用这个缓存程序来缓存网站上的热门图片， 从而提高用户访问这些热门图片的速度。

作为例子， 以下代码展示了将 Redis 的 Logo 图片缓存到键 redis-logo.jpg 里面的方法：

```python
>>> from redis import Redis
>>> from cache import Cache
>>> client = Redis()                      # 使用二进制编码方式打开客户端
>>> cache = Cache(client)
>>> image = open("redis-logo.jpg", "rb")  # 以二进制只读方式打开图片文件
>>> data = image.read()                   # 读取文件内容
>>> image.close()                         # 关闭文件
>>> cache.set("redis-logo.jpg", data)     # 将内存缓存到键 redis-logo.jpg 里面
>>> cache.get("redis-logo.jpg")[:20]      # 读取二进制数据的前 20 个字节
b'\xff\xd8\xff\xe0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00'
```

# 示例：锁

锁是一种同步机制， 它可以保证一项资源在任何时候只能被一个进程使用， 如果有其他进程想要使用相同的资源， 那么它们就必须等待， 直到正在使用资源的进程放弃使用权为止。

一个锁实现通常会有获取（acquire）和释放（release）这两种操作：

- 获取操作用于取得资源的独占使用权。 在任何时候， 最多只能有一个进程取得锁， 我们把成功取得锁的这个进程称之为锁的持有者。 在锁已经被持有的情况下， 所有尝试再次获取锁的操作都会失败。

- 释放操作用于放弃资源的独占使用权， 一般由锁的持有者调用。 在锁被释放之后， 其他进程就可以再次尝试获取这个锁了。

以下展示了一个使用字符串键实现的锁程序， 这个程序会根据给定的字符串键是否有值来判断锁是否已经被获取， 而针对锁的获取操作和释放操作则是分别通过设置字符串键和删除字符串键来完成的。

```python
VALUE_OF_LOCK = "locking"

class Lock:

    def __init__(self, client, key):
        self.client = client
        self.key = key

    def acquire(self):
        """
        尝试获取锁。
        成功时返回 True ，失败时返回 False 。
        """
        result = self.client.set(self.key, VALUE_OF_LOCK, nx=True)
        return result is True

    def release(self):
        """
        尝试释放锁。
        成功时返回 True ，失败时返回 False 。
        """
        return self.client.delete(self.key) == 1
```

获取操作 acquire() 方法是通过执行带有 NX 选项的 SET 命令来实现的：

`result = self.client.set(self.key, VALUE_OF_LOCK, nx=True)`

NX 选项的效果确保了代表锁的字符串键只会在没有值的情况下被设置：

- 如果给定的字符串键没有值， 那么说明锁尚未被获取， SET 命令将执行设置操作， 并将 result 变量的值设置为 True ；

- 与此相反， 如果给定的字符串键已经有值了， 那么说明锁已经被获取， SET 命令将放弃执行设置操作， 并将 result 变量的值将为 None ；

acquire() 方法最后会通过检查 result 变量的值是否为 True 来判断自己是否成功取得了锁。

释放操作 release() 方法使用了本书之前没有介绍过的 DEL 命令， 这个命令接受一个或多个数据库键作为参数， 尝试删除这些键以及与之相关联的值， 并返回被成功删除的键数量作为结果：

`DEL key [key ...]`

因为 Redis 的 DEL 命令和 Python 的 del 关键字重名， 所以在 redis-py 客户端中， 执行 DEL 命令实际上是通过调用 delete() 方法来完成的：

`self.client.delete(self.key) == 1`

release() 方法通过检查 delete() 方法的返回值是否为 1 来判断删除操作是否执行成功： 如果用户尝试对一个尚未被获取的锁执行 release() 方法， 那么方法将返回 false ， 表示没有锁被释放。

在使用 DEL 命令删除代表锁的字符串键之后， 字符串键将重新回到没有值的状态， 这时用户就可以再次调用 acquire() 方法去获取锁了。

以下代码演示了这个锁的使用方法：

```python
>>> from redis import Redis
>>> from lock import Lock
>>> client = Redis(decode_responses=True)
>>> lock = Lock(client, 'test-lock')
>>> lock.acquire()  # 成功获取锁
True
>>> lock.acquire()  # 锁已被获取，无法再次获取
False
>>> lock.release()  # 释放锁
True
>>> lock.acquire()  # 锁释放之后可以再次被获取
True
```

实现了基本的获取和释放功能， 但它并不完美：

- 因为这个锁的释放操作无法验证进程的身份， 所以无论执行释放操作的进程是否就是锁的持有者， 锁都会被释放。 如果锁被持有者以外的其他进程释放了的话， 那么系统中可能就会同时出现多个锁， 导致锁的唯一性被破坏。

- 这个锁的获取操作不能设置最大加锁时间， 它无法让锁在超过给定的时限之后自动释放。 因此， 如果持有锁的进程因为故障或者编程错误而没有在退出之前主动释放锁， 那么锁就会一直处于已被获取的状态， 导致其他进程永远无法取得锁。

# MSET：一次为多个字符串键设置值

除了 SET 命令和 GETSET 命令之外， Redis 还提供了 MSET 命令用于对字符串键进行设置。 跟 SET 命令和 GETSET 命令只能设置单个字符串键的做法不同， MSET 命令可以一次为多个字符串键设置值：

`MSET key value [key value ...]`

作为例子， 以下代码展示了如何使用一条 MSET 命令去设置 message 、 number 和 homepage 三个键：

```
redis> MSET message "hello world" number "10086" homepage "redis.io"
OK

redis> GET message
"hello world"

redis> GET number
"10086"

redis> GET homepage
"redis.io"
```

跟 SET 命令一样， MSET 命令也会在执行设置操作之后返回 OK 表示设置成功。 此外， 如果给定的字符串键已经有相关联的值， 那么 MSET 命令也会直接使用新值去覆盖已有的旧值。

比如以下代码就展示了怎样使用 MSET 命令去覆盖上一个 MSET 命令为 message 键和 number 键设置的值：

```
redis> MSET message "good morning!" number "12345"
OK

redis> GET message
"good morning!"

redis> GET number
"12345"
```

MSET 命令除了可以让用户更为方便地执行多个设置操作之外， 还能够有效地提高程序的效率： 执行多条 SET 命令需要客户端和服务器之间进行多次网络通信， 并因此耗费大量的时间； 通过使用一条 MSET 命令去代替多条 SET 命令， 可以将原本所需的多次网络通信降低为只需一次网络通信， 从而有效地减少程序执行多个设置操作时所需的时间。

# MGET：一次获取多个字符串键的值

MGET 命令就是一个多键版本的 GET 命令， 它接受一个或多个字符串键作为参数， 并返回这些字符串键的值：

`MGET key [key ...]`

MGET 命令返回一个列表作为结果， 这个列表按照用户执行命令时给定键的顺序排列各个键的值： 比如说， 列表的第一个元素就是第一个给定键的值， 而列表的第二个元素则是第二个给定键的值， 以此类推。

作为例子， 以下代码展示了如何使用一条 MGET 命令去获取 message 、 number 和 homepage 三个键的值：

```
redis> MGET message number homepage
1) "hello world"    -- message 键的值
2) "10086"          -- number 键的值
3) "redis.io"       -- homepage 键的值
```

跟 GET 命令一样， MGET 命令在碰到不存在的键时也会返回空值：

```
redis> MGET not-exists-key
1) (nil)
```

跟 MSET 命令类似， MGET 命令也可以将执行多个获取操作所需的网络通信次数从原来的 N 次降低至只需一次， 从而有效地提高程序的运行效率。

# MSETNX：只在键不存在的情况下，一次为多个字符串键设置值

MSETNX 命令跟 MSET 命令一样， 都可以对多个字符串键进行设置：

`MSETNX key value [key value ...]`

MSETNX 跟 MSET 的主要区别在于 MSETNX 只会在所有给定键都不存在的情况下对键进行设置， 而不会像 MSET 那样直接覆盖键已有的值： 如果在给定键当中， 有哪怕一个键已经有值了， 那么 MSETNX 命令也会放弃对所有给定键的设置操作。 MSETNX 命令在成功执行设置操作时返回 1 ， 在放弃执行设置操作时则返回 0 。

在以下的这段代码中， 因为键 k4 已经存在， 所以 MSETNX 将放弃对键 k1 、 k2 、 k3 和 k4 进行设置操作：

```
redis> MGET k1 k2 k3 k4
1) (nil)            -- 键 k1 、 k2 和 k3 都不存在
2) (nil)
3) (nil)
4) "hello world"    -- 键 k4 已存在

redis> MSETNX k1 "one" k2 "two" k3 "three" k4 "four"
(integer) 0    -- 因为键 k4 已存在，所以 MSETNX 未能执行设置操作

redis> MGET k1 k2 k3 k4    -- 各个键的值没有变化
1) (nil)
2) (nil)
3) (nil)
4) "hello world"
```

但是如果我们只对不存在的键 k1 、 k2 和 k3 进行设置， 那么 MSETNX 可以正常地完成设置操作：

```
redis> MSETNX k1 "one" k2 "two" k3 "three"
(integer) 1    -- 所有给定键都不存在，成功执行设置操作

redis> MGET k1 k2 k3 k4
1) "one"            -- 刚刚使用 MSETNX 设置的三个值
2) "two"
3) "three"
4) "hello world"    -- 之前已经存在的键 k4 的值没有改变
```

# 示例：储存文章信息

在构建应用程序的时候， 我们经常会需要批量地设置和获取多项信息。 以博客程序为例子：

- 当用户想要注册成为博客的作者时， 程序就需要把这位作者的名字、账号、密码、注册时间等多项信息储存起来， 并在用户登录的时候取出这些信息。

- 又比如说， 当博客的作者想要撰写一篇新文章的时候， 程序就需要把文章的标题、内容、作者、发表时间等多项信息储存起来， 并在用户阅读文章的时候取出这些信息。

通过使用 MSET 命令、 MSETNX 命令以及 MGET 命令， 我们可以实现上面提到的这些批量设置操作和批量获取操作。 比如代码清单 2-3 就展示了一个文章储存程序， 这个程序使用 MSET 命令和 MSETNX 命令将文章的标题、内容、作者、发表时间等多项信息储存到不同的字符串键里面， 并通过 MGET 命令从这些键里面获取文章的各项信息。

```python
from time import time  # time() 函数用于获取当前 Unix 时间戳

class Article:

    def __init__(self, client, article_id):
        self.client = client
        self.id = str(article_id)
        self.title_key = "article::" + self.id + "::title"
        self.content_key = "article::" + self.id + "::content"
        self.author_key = "article::" + self.id + "::author"
        self.create_at_key = "article::" + self.id + "::create_at"

    def create(self, title, content, author):
        """
        创建一篇新的文章，创建成功时返回 True ，
        因为文章已存在而导致创建失败时返回 False 。
        """
        article_data = {
            self.title_key: title,
            self.content_key: content,
            self.author_key: author,
            self.create_at_key: time()
        }
        return self.client.msetnx(article_data)

    def get(self):
        """
        返回 ID 对应的文章信息。
        """
        result = self.client.mget(self.title_key,
                                  self.content_key,
                                  self.author_key,
                                  self.create_at_key)
        return {"id": self.id, "title": result[0], "content": result[1],
                "author": result[2], "create_at": result[3]}

    def update(self, title=None, content=None, author=None):
        """
        对文章的各项信息进行更新，
        更新成功时返回 True ，失败时返回 False 。
        """
        article_data = {}
        if title is not None:
            article_data[self.title_key] = title
        if content is not None:
            article_data[self.content_key] = content
        if author is not None:
            article_data[self.author_key] = author
        return self.client.mset(article_data)
```

这个文章储存程序比较长， 让我们来逐个分析它的各项功能。 首先， Article 类的初始化方法 __init__() 接受一个 Redis 客户端和一个文章 ID 作为参数， 并将文章 ID 从数字转换为字符串：

```python
self.id = str(article_id)
```

接着程序会使用这个字符串格式的文章 ID ， 构建出用于储存文章各项信息的字符串键的键名：

```python
self.title_key = "article::" + self.id + "::title"
self.content_key = "article::" + self.id + "::content"
self.author_key = "article::" + self.id + "::author"
self.create_at_key = "article::" + self.id + "::create_at"
```

在这些键当中， 第一个键将用于储存文章的标题， 第二个键将用于储存文章的内容， 第三个键将用于储存文章的作者， 而第四个键则会用于储存文章的创建时间。

当用户想要根据给定的文章 ID 创建具体的文章时， 他就需要调用 create() 方法， 并传入文章的标题、内容以及作者作为参数。 create() 方法会把以上这些信息以及当前的 UNIX 时间戳放入到一个 Python 字典里面：

```python
article_data = {
    self.title_key: title,
    self.content_key: content,
    self.author_key: author,
    self.create_at_key: time()
}
```

article_data 字典的键储存了代表文章各项信息的字符串键的键名， 而与这些键相关联的则是这些字符串键将要被设置的值。 接下来， 程序会调用 MSETNX 命令， 对字典中给定的字符串键进行设置：

```python
self.client.msetnx(article_data)
```

因为 create() 方法的设置操作是通过 MSETNX 命令来进行的， 所以这一操作只会在所有给定字符串键都不存在的情况下进行：

- 如果给定的字符串键已经有值了， 那么说明与给定 ID 相对应的文章已经存在。 在这种情况下， MSETNX 命令将放弃执行设置操作， 并且 create() 方法也会向调用者返回 False 表示文章创建失败。

- 与此相反， 如果给定的字符串键尚未有值， 那么 create() 方法将根据用户给定的信息创建文章， 并在成功之后返回 True 。

在成功创建文章之后， 用户就可以使用 get() 方法去获取文章的各项信息了。 get() 方法会调用 MGET 命令， 从各个字符串键里面取出文章的标题、内容、作者等信息， 并把这些信息储存到 result 列表中：

```python
result = self.client.mget(self.title_key,
                          self.content_key,
                          self.author_key,
                          self.create_at_key)
```

为了让用户可以更方便地访问文章的各项信息， get() 方法会将储存在 result 列表里面的文章信息放入到一个字典里面， 然后再返回给用户：

```python
return {"id": self.id, "title": result[0], "content": result[1],
        "author": result[2], "create_at": result[3]}
```

这样做的好处有两点：

1. 它隐藏了 get() 方法由 MGET 命令实现这一底层细节。 如果程序直接向用户返回 result 列表， 那么用户就必须知道列表中的各个元素代表文章的哪一项信息， 然后通过列表索引来访问文章的各项信息。 这种做法非常不方便， 而且也非常容易出错。

2. 返回一个字典可以让用户以 dict[key] 这样的方式去访问文章的各个属性， 比如使用 article["title"] 去访问文章的标题， 使用 article["content"] 去访问文章的内容， 诸如此类， 这使得针对文章数据的各项操作可以更方便地进行。

另外要注意的一点是， 虽然用户可以通过访问 Article 类的 id 属性来获得文章的 ID ， 但是为了方便起见， get() 方法在返回文章信息的时候也会将文章的 ID 包含在字典里面一并返回。

对文章信息进行更新的 update() 方法是整个程序最复杂的部分。 首先， 为了让用户可以自由选择需要更新的信息项， 这个函数在定义时使用了 Python 的具名参数特性：

def update(self, title=None, content=None, author=None):

通过具名参数， 用户可以根据自己想要更新的文章信息项来决定传入哪个参数， 而不需要更新的信息项则会被赋予默认值 None ：

- 比如说， 如果用户只想要更新文章的标题， 那么只需要调用 update(title=new_title) 即可；

- 又比如说， 如果用户想要同时更新文章的内容和作者， 那么只需要调用 update(content=new_content, author=new_author) 即可；

诸如此类。

在定义了具名参数之后， update() 方法会检查各个参数的值， 并将那些不为 None 的参数以及与之相对应的字符串键键名放入到 article_data 字典里面：

```python
article_data = {}
if title is not None:
    article_data[self.title_key] = title
if content is not None:
    article_data[self.content_key] = content
if author is not None:
    article_data[self.author_key] = author
```

article_data 字典中的键就是需要更新的字符串键的键名， 而与之相关联的则是这些字符串键的新值。

在一切准备就绪之后， update() 方法会根据 article_data 字典中设置好的键值对， 调用 MSET 命令对文章进行更新：

```python
self.client.mset(article_data)
```

以下代码展示了这个文章储存程序的使用方法：

```python
>>> from redis import Redis
>>> from article import Article
>>> client = Redis(decode_responses=True)
>>> article = Article(client, 10086)                   # 指定文章 ID
>>> article.create('message', 'hello world', 'peter')  # 创建文章
True
>>> article.get()                                      # 获取文章
{'id': '10086', 'title': 'message', 'content': 'hello world',
 'author': 'peter', 'create_at': '1551199163.4296808'}
>>> article.update(author="john")                      # 更新文章的作者
True
>>> article.get()                                      # 再次获取文章
{'id': '10086', 'title': 'message', 'content': 'hello world',
 'author': 'john', 'create_at': '1551199163.4296808'}
```

键的命名格式

Article 程序使用了多个字符串键去储存文章信息， 并且每个字符串键的名字都是以 article::<id>::<attribute> 格式命名的， 这是一种 Redis 使用惯例： Redis 用户通常会为逻辑上相关联的键设置相同的前缀， 并通过分隔符来区分键名的各个部分， 以此来构建一种键的命名格式。

比如对于 article::10086::title 、 article::10086::author 这些键来说， article 前缀表明这些键都储存着与文章信息相关的数据， 而分隔符 :: 则区分开了键名里面的前缀、ID 以及具体的属性。 除了 :: 符号之外， 常用的键名分隔符还包括 . 符号， 比如 article.10086.title ； 或者 -> 符号， 比如 article->10086->title ； 又或者 | 符号， 比如 article|10086|title ； 诸如此类。

分隔符的选择通常只是一个个人喜好的问题， 而键名的具体格式也可以根据需要进行构造： 比如说， 如果你不喜欢 article::<id>::<attribute> 格式， 那么也可以考虑使用 article::<attribute>::<id> 格式， 诸如此类。 唯一需要注意的是， 一个程序应该只使用一种键名分隔符， 并且持续地使用同一种键名格式， 以免造成混乱。

通过使用相同的格式去命名逻辑上相关联的键， 我们可以让程序产生的数据结构变得更容易被理解， 并且在有需要的时候， 还可以根据特定的键名格式， 在数据库里面以模式匹配的方式查找指定的键。

# STRLEN：获取字符串值的字节长度

通过对字符串键执行 STRLEN 命令， 用户可以取得字符串键储存的值的字节长度：

`STRLEN key`

以下代码展示了如何使用 STRLEN 去获取不同字符串值的字节长度：

```
redis> GET number
"10086"

redis> STRLEN number    -- number 键的值长 5 字节
(integer) 5

redis> GET message
"hello world"

redis> STRLEN message   -- message 键的值长 11 字节
(integer) 11

redis> GET book
"The Design and Implementation of Redis"

redis> STRLEN book      -- book 键的值长 38 字节
(integer) 38
```

对于不存在的键， STRLEN 命令将返回 0 ：

```
redis> STRLEN not-exists-key
(integer) 0
```

# 字符串值的索引

因为每个字符串都是由一系列连续的字节组成的， 所以字符串中的每个字节实际上都拥有与之相对应的索引。 Redis 为字符串键提供了一系列索引操作命令， 这些命令允许用户通过正数索引或者负数索引， 对字符串值的某个字节或者某个部分进行处理， 其中：

- 字符串值的正数索引以 0 为开始， 从字符串的开头向结尾不断递增；

- 字符串值的负数索引以 -1 为开始， 从字符串的结尾向开头不断递减。

 "hello world" 的字符串索引示例

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_59db2300c4679ba882397f2221f7bda2_r.png)

# GETRANGE：获取字符串值指定索引范围上的内容

通过使用 GETRANGE 命令， 用户可以获取字符串值从 start 索引开始， 直到 end 索引为止的所有内容：

`GETRANGE key start end`

GETRANGE 命令接受的是闭区间索引范围， 也即是说， 位于 start 索引和 end 索引上的值也会被包含在命令返回的内容当中。

举个例子， 以下代码展示了如何使用 GETRANGE 命令去获取 message 键的值的不同部分：

```
redis> GETRANGE message 0 4     -- 获取字符串值索引 0 至索引 4 上的内容
"hello"

redis> GETRANGE message 6 10    -- 获取字符串值索引 6 至索引 10 上的内容
"world"

redis> GETRANGE message 3 7     -- 获取字符串值的中间部分
"lo wo"

redis> GETRANGE message -11 -7  -- 使用负数索引获取指定内容
"hello"
```

GETRANGE 命令执行示例

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_c3aa0e4148e8ab7820c36e3f2844f5d7_r.png)

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_37182aeb004706ce083e0328fc8f85db_r.png)

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_34e08d2e4f5ef0252fa1072eb7e19eee_r.png)

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_1faa6ab3f148e9145b9a4d0853c5af4f_r.png)

# SETRANGE：对字符串值的指定索引范围进行设置

通过使用 SETRANGE 命令， 用户可以将字符串键的值从索引 index 开始的部分替换为指定的新内容， 被替换内容的长度取决于新内容的长度：

`SETRANGE key index substitute`

SETRANGE 命令在执行完设置操作之后， 会返回字符串值当前的长度作为结果。

比如说， 我们可以通过执行以下命令， 将 message 键的值从原来的 "hello world" 修改为 "hello Redis" ：

```
redis> GET message
"hello world"

redis> SETRANGE message 6 "Redis"
(integer) 11    -- 字符串值当前的长度为 11 字节

redis> GET message
"hello Redis"
```

这个例子中的 SETRANGE 命令会将 message 键的值从索引 6 开始的内容替换为 "Redis" ， 图 2-7 展示了这个命令的执行过程。

SETRANGE 命令修改 message 键的过程

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_319141a85c9c073c9c2a730748d2ce8c_r.png)

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_541d973fa4385157f1cffb926fc8380b_r.png)

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_328e1a46f86a8e569c00571a58257c17_r.png)

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_be7f10bc0e605cc2fe4e06fce97a953f_r.png)

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_6564281c5f1b31ef4de1ff9e44166eda_r.png)

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_f4ff69337de122b4f1d130637a572653_r.png)

自动扩展被修改的字符串

当用户给定的新内容比被替换的内容更长时， SETRANGE 命令就会自动扩展被修改的字符串值， 从而确保新内容可以顺利写入。

比如说， 以下代码就展示了如何通过 SETRANGE 命令， 将 message 键的值从原来的 11 字节长修改为 41 字节长：

```
redis> GET message
"hello Redis"

redis> SETRANGE message 5 ", this is a message send from peter."
(integer) 41

redis> GET message
"hello, this is a message send from peter."
```

SETRANGE 命令的执行过程示例

SETRANGE 命令执行之前的字符串值

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_37f5b78322a5425bb5a69958d0106d34_r.png)

将字符串值扩展至 41 字节长

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_0735452ba1acc96c69aa30dc7248d6b5_r.png)

对字符串值进行设置

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_5f0730a440ec29454fd55bbd17a2c20c_r.png)

在值里面填充空字节

SETRANGE 命令除了会根据用户给定的新内容自动扩展字符串值之外， 还会根据用户给定的 index 索引扩展字符串： 当用户给定的 index 索引超出字符串值的长度时， 字符串值末尾直到索引 index-1 之间的部分将使用空字节进行填充， 换句话说， 这些字节的所有二进制位都会被设置为 0 。

举个例子， 对于字符串键 greeting 来说：

```
redis> GET greeting
"hello"

```

当我们执行以下命令时：

```
redis> SETRANGE greeting 10 "world"
(integer) 15
```

SETRANGE 命令会先将字符串值扩展为 15 个字节长， 然后将 "hello" 末尾直到索引 9 之间的所有字节都填充为空字节， 最后再将索引 10 到索引 14 的内容设置为 "world" 。 图 2-9 展示了这个扩展、填充、最后设置的过程。

执行 SETRANGE 之前的字符串值

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_a3d81e017a8f2af42e2d061043d41d8b_r.png)

将字符串值从 5 个字节扩展至 15 个字节

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_e9c117de52d6f0159be1139770063d74_r.png)

使用空字节填充索引 5 至索引 9

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_44914a15f62002ef0fd1fadd67a4b63e_r.png)

将索引 10 至索引 14 的内容设置为 “world”

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_96e7daac2cf2f0ca1216f111ff2a01d4_r.png)

通过执行 GET 命令， 我们可以取得 greeting 键在执行 SETRANGE 命令之后的值：

```
redis> GET greeting
"hello\x00\x00\x00\x00\x00world"
```

可以看到， greeting 键的值现在包含了多个 \x00 符号， 而每个 \x00 符号就代表一个空字节。

# 示例：给文章储存程序加上文章长度计数功能和文章预览功能

在前面的内容中， 我们使用 MSET 、 MGET 等命令构建了一个储存文章信息的程序， 在学习了 STRLEN 命令和 GETRANGE 命令之后， 我们可以给这个文章储存程序加上两个新功能， 其中一个是文章长度计数功能， 而另一个则是文章预览功能：

- 文章长度计数功能用于显示文章内容的长度， 读者可以通过这个长度值来了解一篇文章大概有多长， 从而决定是否阅读一篇文章。

- 文章预览功能则用于显示文章开头的一部分内容， 这些内容可以帮助读者快速地了解文章本身， 并吸引读者进一步阅读整篇文章。

其中文章长度计数功能是通过对文章内容执行 STRLEN 命令来实现的， 而文章预览功能则是通过对文章内容执行 GETRANGE 命令来实现的。

```python
from time import time  # time() 函数用于获取当前 Unix 时间戳

class Article:

    # 省略之前展示过的 __init__()、create() 、update() 等方法……

    def get_content_len(self):
        """
        返回文章内容的字节长度。
        """
        return self.client.strlen(self.content_key)

    def get_content_preview(self, preview_len):
        """
        返回指定长度的文章预览内容。
        """
        start_index = 0
        end_index = preview_len-1
        return self.client.getrange(self.content_key, start_index, end_index)
```

get_content_len() 方法的实现非常简单直接， 没有什么需要说明的。 与此相比， get_content_preview() 方法显得更复杂一些， 让我们来对它进行一些分析。

首先， get_content_preview() 方法会接受一个 preview_len 参数， 用于记录调用者指定的预览长度。 接着程序会根据这个预览长度， 计算出预览内容的起始索引和结束索引：

```python
start_index = 0
end_index = preview_len-1
```

因为预览功能要做的就是返回文章内容的前 preview_len 个字节， 所以上面的这两条赋值语句要做的就是计算并记录文章前 preview_len 个字节所在的索引范围， 其中 start_index 的值总是 0 ， 而 end_index 的值则为 preview_len 减一。 举个例子， 假如用户输入的预览长度为 150 ， 那么 start_index 将被赋值为 0 ， 而 end_index 将被赋值为 149 。

最后， 程序会调用 GETRANGE 命令， 根据上面计算出的两个索引， 从储存着文章内容的字符串键里面取出指定的预览内容：

```python
self.client.getrange(self.content_key, start_index, end_index)
```

以下代码展示了如何使用文章长度计数功能以及文章预览功能：

```python
>>> from redis import Redis
>>> from article import Article
>>> client = Redis(decode_responses=True)
>>> article = Article(client, 12345)
>>> title = "Improving map data on GitHub"
>>> content = "You've been able to view and diff geospatial data on GitHub for a while, but now, in addition to being able to collaborate on the GeoJSON files you upload to GitHub, you can now more easily contribute to the underlying, shared basemap, that provides your data with context."
>>> author = "benbalter"
>>> article.create(title, content, author)  # 将一篇比较长的文章储存起来
True
>>> article.get_content_len()               # 文章总长 273 字节
273
>>> article.get_content_preview(100)        # 获取文章前 100 字节的内容
"You've been able to view and diff geospatial data on GitHub for a while, but now, in addition to bei"
```

# APPEND：追加新内容到值的末尾

通过调用 APPEND 命令， 用户可以将给定的内容追加到字符串键已有值的末尾：

```
APPEND key suffix
```

APPEND 命令在执行追加操作之后， 会返回字符串值当前的长度作为返回值。

举个例子， 对于以下这个名为 description 的键来说：

```
redis> GET description
"Redis"
```

我们可以通过执行以下命令， 将字符串 " is a database" 追加到 description 键已有值的末尾：

```
redis> APPEND description " is a database"
(integer) 19    -- 追加操作执行完毕之后，值的长度
```

以下是 description 键在执行完追加操作之后的值：

```
redis> GET description
"Redis is a database"
```

在此之后， 我们可以继续执行以下 APPEND 命令， 将字符串 " with many different data structure." 追加到 description 键已有值的末尾：

```
redis> APPEND description " with many different data structure."
(integer) 55
```

现在， description 键的值又变成了以下这个样子：

```
redis> GET description
"Redis is a database with many different data structure."
```

description 键的值随着 APPEND 命令的执行而变化

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_9c3eddf72c616aaa2845fc59dfaae420_r.png)

处理不存在的键

如果用户给定的键并不存在， 那么 APPEND 命令会先将键的值初始化为空字符串 "" ， 然后再执行追加操作， 最终效果跟使用 SET 命令为键设置值的情况类似：

```
redis> GET append_msg  -- 键不存在
(nil)

redis> APPEND append_msg "hello"  -- 效果相当于执行 SET append_msg "hello"
(integer) 5

redis> GET append_msg
"hello"
```

当键有了值之后， APPEND 又会像平时一样， 将用户给定的值追加到已有值的末尾：

```
redis> APPEND append_msg ", how are you?"
(integer) 19

redis> GET append_msg
"hello, how are you?"
```

APPEND 的判断过程

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_3905897f5677ef655046a7705bfb8a43_r.png)

摘抄[Redis使用手册](http://redisguide.com/introduction.html#id6 "Redis使用手册")