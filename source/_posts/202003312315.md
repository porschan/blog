---
title: Redis - 散列
date: 2020/3/31 23:48:21
---

# 散列（Hash）

在前面的《字符串》一章中， 我们曾经看到过如何使用多个字符串键去储存相关联的一组数据。 比如在字符串键实现的文章储存程序中， 程序就会为每篇文章创建四个字符串键， 并把文章的标题、内容、作者和创建时间分别储存到这四个字符串键里面， 图 3-1 就展示了一个使用字符串键储存文章数据的例子。

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_cedaf54935e7afe9401d55886a74217a_r.png)

使用多个字符串键储存相关联数据虽然在技术上是可行的， 但是在实际应用中却并不是最有效的方法， 这种储存方法至少存在以下三个问题：

- 首先， 程序每储存一组相关联的数据， 就必须在数据库里面同时创建多个字符串键， 这样的数据越多， 数据库包含的键数量也会越多。 数量庞大的键会对数据库某些操作的执行速度产生影响， 并且维护这些键也会产生大量的资源消耗。

- 其次， 为了在数据库里面标识出相关联的字符串键， 程序需要为它们加上相同的前缀， 但键名实际上也是一种数据， 储存键名也需要耗费内存空间， 因此重复出现的键名前缀实际上导致很多内存空间被白白浪费了。 此外， 带前缀的键名还降低了键名的可读性， 让人无法一眼看清键的真正用途， 比如键名 article::10086::author 就远不如键名 author 简洁， 而键名 article::10086::title 也远不如键名 title 来得简洁。

- 最后， 虽然程序在逻辑上会把带有相同前缀的字符串键看作是相关联的一组数据， 但是在 Redis 看来， 它们只不过是储存在同一个数据库中的不同字符串键而已。 因此当程序需要处理一组相关联的数据时， 它就必须对所有有关的字符串键都执行相同的操作。 比如说， 如果程序想要删除 ID 为 10086 的文章， 那么它就必须把 article::10086::title 、 article::10086::content 等四个字符串键都删掉才行， 这给文章的删除操作带来了额外的麻烦， 并且还可能会因为漏删或者错删了某个键而发生错误。

为了解决以上问题， 我们需要一种能够真正地把相关联的数据打包起来储存的数据结构， 而这种数据结构就是本章要介绍的散列键。

### 散列简介

Redis 的散列键会将一个键和一个散列在数据库里面关联起来， 用户可以在散列里面为任意多个字段（field）设置值。 跟字符串键一样， 散列的字段和值既可以是文本数据， 也可以是二进制数据。

通过使用散列键， 用户可以把相关联的多项数据储存到同一个散列里面， 以便对这些数据进行管理， 又或者针对它们执行批量操作。 比如图 3-2 就展示了一个使用散列储存文章数据的例子， 在这个例子中， 散列的键为 article::10086 ， 而这个键对应的散列则包含了四个字段， 其中：

- "title" 字段储存着文章的标题 "greeting" ；

- "content" 字段储存着文章的内容 "hello world" ；

- "author" 字段储存着文章的作者名字 "peter" ；

- "create_at" 字段储存着文章的创建时间 "1442744762.631885" 。

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_5b1e41bc2f191936b48a307435fbc5de_r.png)

与之前使用字符串键储存文章数据的做法相比， 使用散列储存文章数据只需要在数据库里面创建一个键， 并且因为散列的字段名不需要添加任何前缀， 所以它们可以直接反映字段值储存的是什么数据。

Redis 为散列键提供了一系列操作命令， 通过使用这些命令， 用户可以：

- 为散列的字段设置值， 又或者只在字段不存在的情况下为它设置值。

- 从散列里面获取给定字段的值。

- 对储存着数字值的字段执行加法操作或者减法操作。

- 检查给定字段是否存在于散列当中。

- 从散列里面删除指定字段。

- 查看散列包含的字段数量。

- 一次为散列的多个字段设置值， 又或者一次从散列里面获取多个字段的值。

- 获取散列包含的所有字段、所有值又或者所有字段和值。

本章接下来将对以上提到的散列操作进行介绍， 说明如何使用这些操作去构建各种有用的应用程序， 并在最后详细地说明散列键与字符串键之间的区别。

### HSET：为字段设置值

用户可以通过执行 HSET 命令， 为散列中的指定字段设置值：

```
HSET hash field value
```

根据给定的字段是否已经存在于散列里面， HSET 命令的行为也会有所不同：

- 如果给定字段并不存在于散列当中， 那么这次设置就是一次创建操作， 命令将在散列里面关联起给定的字段和值， 然后返回 1 。

- 如果给定的字段原本已经存在于散列里面， 那么这次设置就是一次更新操作， 命令将使用用户给定的新值去覆盖字段原有的旧值， 然后返回 0 。

举个例子， 通过执行以下 HSET 命令， 我们可以创建出一个包含了四个字段的散列， 这四个字段分别储存了文章的标题、内容、作者以及创建日期：

```
redis> HSET article::10086 title "greeting"
(integer) 1

redis> HSET article::10086 content "hello world"
(integer) 1

redis> HSET article::10086 author "peter"
(integer) 1

redis> HSET article::10086 created_at "1442744762.631885"
(integer) 1
```

HSET 命令执行之前的数据库， article::10086 散列并不存在

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_d00c4da6a6fe154c6ae9bad779f43f42_r.png)

执行 HSET article::10086 title "greeting" 命令之后

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_f1a6f24751fa03eb4d842922ed0b9fbd_r.png)

执行 HSET article::10086 content "hello world" 命令之后

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_da2bfbf4223cf2184a0bdf234c48fa25_r.png)

执行 HSET article::10086 author "peter" 命令之后

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_244b9c743474f6872585fb3520ceb05c_r.png)

执行 HSET article::10086 created_at "1442744762.631885" 命令之后

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_bcefe9da045b0d9d364a3c188397a0ac_r.png)

散列包含的字段就跟数据库包含的键一样， 在实际中都是以无序方式进行排列的， 不过本书为了展示方便， 一般都会把新字段添加到散列的末尾， 排在所有已有字段的后面。

使用新值覆盖旧值
正如之前所说， 如果用户在调用 HSET 命令时， 给定的字段已经存在于散列当中， 那么 HSET 命令将使用用户给定的新值去覆盖字段已有的旧值， 并返回 0 表示这是一次更新操作。

比如说， 以下代码就展示了如何使用 HSET 命令去更新 article::10086 散列的 title 字段以及 content 字段：

```
redis> HSET article::10086 title "Redis Tutorial"
(integer) 0

redis> HSET article::10086 content "Redis is a data structure store, ..."
(integer) 0
```

被更新之后的 article::10086 散列

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_9b6540600c71fd91193240b0d73cde26_r.png)

### HSETNX：只在字段不存在的情况下为它设置值

HSETNX 命令的作用和 HSET 命令的作用非常相似， 它们之间的区别在于， HSETNX 命令只会在指定字段不存在的情况下执行设置操作：

```
HSETNX hash field value
```

HSETNX 命令在字段不存在并且成功为它设置值时返回 1 ， 在字段已经存在并导致设置操作未能成功执行时返回 0 。

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_eeca77ec5fa2b4c08f878cd40564708c_r.png)

举个例子， 对于图 3-5 所示的 article::10086 散列来说， 执行以下 HSETNX 命令将不会对散列产生任何影响， 因为 HSETNX 命令想要设置的 title 字段已经存在：

```
redis> HSETNX article::10086 title "Redis Performance Test"
(integer) 0    -- 设置失败
```

相反地， 如果我们使用 HSETNX 命令去对尚未存在的 view_count 字段进行设置， 那么这个命令将会顺利执行， 并将 view_count 字段的值设置为 100 ：

```
redis> HSETNX article::10086 view_count 100
(integer) 1    -- 设置成功
```

展示了 HSETNX 命令成功执行之后的 article::10086 散列。

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_94b42148f13a96839e44733c86702ee4_r.png)

### HGET：获取字段的值

HGET 命令可以根据用户给定的字段， 从散列里面获取该字段的值：

```
HGET hash field
```

![](https://chanchifeng.com/mindoc/uploads/redis/images/m_a8a65553607fdcd6863690e373f3b414_r.png)

比如对于图 3-7 所示的两个散列键来说， 执行以下命令可以从 article::10086 散列里面获取 author 字段的值：

```
redis> HGET article::10086 author
"peter"
```

而执行以下命令则可以从 article::10086 散列里面获取 created_at 字段的值：

```
redis> HGET article::10086 created_at
"1442744762.631885"
```

又比如说， 如果我们想要从 account::54321 散列里面获取 email 字段的值， 那么可以执行以下命令：

```
redis> HGET account::54321 email
"peter1984@spam_mail.com"
```

处理不存在的字段或者不存在的散列
如果用户给定的字段并不存在于散列当中， 那么 HGET 命令将返回一个空值。

举个例子， 在以下代码中， 我们尝试从 account::54321 散列里面获取 location 字段的值， 但由于 location 字段并不存在于 account::54321 散列当中， 所以 HGET 命令将返回一个空值：

```
redis> HGET account::54321 location
(nil)
```

尝试从一个不存在的散列里面获取一个不存在的字段值， 得到的结果也是一样的：

```
redis> HGET not-exists-hash not-exists-field
(nil)
```

摘抄：[Redis使用手册](http://redisguide.com/hash.html "Redis使用手册")